import streamlit as st
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Charger les donn√©es avec le syst√®me de mise en cache
@st.cache_data
def load_data():
    # Chemins relatifs des fichiers CSV
    train_path = 'data/train.csv'
    test_path = 'data/test.csv'

    # Charger les fichiers CSV
    train_df = pd.read_csv(train_path, sep=',')
    test_df = pd.read_csv(test_path, sep=',')
    return train_df, test_df

# Fonction de pr√©traitement des donn√©es
def preprocess_data(train_df, test_df):
    # V√©rifier si la colonne 'id' existe avant de la supprimer dans test_df
    if 'id' in test_df.columns:
        test_df = test_df.drop(columns=["id"])

    # V√©rifier si la colonne 'price_range' existe dans train_df
    if 'price_range' not in train_df.columns:
        st.error("La colonne 'price_range' est manquante dans les donn√©es d'entra√Ænement.")
        return None, None, None

    # Encoder les variables cat√©gorielles
    train_df = pd.get_dummies(train_df, drop_first=True)
    test_df = pd.get_dummies(test_df, drop_first=True)

    # Aligner les colonnes entre train et test
    for col in train_df.columns:
        if col not in test_df.columns:
            test_df[col] = 0
    test_df = test_df[train_df.columns]

    # S√©parer les caract√©ristiques (X) et la cible (y) pour l'entra√Ænement
    X = train_df.drop(columns=["price_range"])
    y = train_df["price_range"]
    
    return X, y, test_df

# Entra√Æner le mod√®le Random Forest
def train_random_forest(X, y):
    # Diviser les donn√©es en entra√Ænement et test
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Cr√©er et entra√Æner le mod√®le
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)

    # Pr√©dictions sur l'ensemble de test
    y_pred = model.predict(X_test)

    # Calcul de la pr√©cision et autres m√©triques
    accuracy = accuracy_score(y_test, y_pred)
    classification_rep = classification_report(y_test, y_pred, output_dict=True)
    confusion_mat = confusion_matrix(y_test, y_pred)
    
    return model, accuracy, classification_rep, confusion_mat

# Entra√Æner le mod√®le de r√©gression logistique
def train_logistic_regression(X, y):
    # Diviser les donn√©es en entra√Ænement et test
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Cr√©er et entra√Æner le mod√®le
    model = LogisticRegression(max_iter=1000, random_state=42)
    model.fit(X_train, y_train)

    # Pr√©dictions sur l'ensemble de test
    y_pred = model.predict(X_test)

    # Calcul de la pr√©cision et autres m√©triques
    accuracy = accuracy_score(y_test, y_pred)
    classification_rep = classification_report(y_test, y_pred, output_dict=True)
    confusion_mat = confusion_matrix(y_test, y_pred)
    
    return model, accuracy, classification_rep, confusion_mat

# Pr√©diction de la plage de prix pour un t√©l√©phone donn√©
def predict_price(model, features):
    # Assurez-vous que les colonnes sont bien align√©es avec le mod√®le
    prediction = model.predict(features)
    return prediction[0]

# Visualiser l'importance des caract√©ristiques pour Random Forest
def plot_feature_importance(model):
    """
    Fonction pour afficher l'importance des caract√©ristiques du mod√®le RandomForest.
    """
    feature_importances = model.feature_importances_
    indices = np.argsort(feature_importances)[::-1]

    plt.figure(figsize=(10, 6))
    plt.title("Importance des Caract√©ristiques")
    plt.barh(range(len(indices)), feature_importances[indices], align="center")
    plt.yticks(range(len(indices)), np.array(model.feature_names_in_)[indices])
    plt.xlabel("Importance")
    st.pyplot(plt)

# Fonction principale
def main():
    # Titre de l'application
    st.set_page_config(page_title="Pr√©diction de Plage de Prix des T√©l√©phones", page_icon="üì±", layout="wide")
    
    # Utilisation de la barre lat√©rale pour la navigation
    st.sidebar.title("Navigation")
    app_mode = st.sidebar.radio("Choisissez une option", ["Pr√©diction", "√âvaluation du mod√®le"])

    # V√©rification si le mod√®le est d√©j√† charg√© dans session_state
    if 'model' not in st.session_state:
        st.session_state.model = None
        st.session_state.accuracy = None
        st.session_state.classification_rep = None
        st.session_state.confusion_mat = None

    if app_mode == "Pr√©diction":
        # Titre principal
        st.title("Pr√©diction de la Plage de Prix des T√©l√©phones")
        st.markdown(
            """
            Cette application permet de pr√©dire la **plage de prix** des t√©l√©phones en fonction de leurs caract√©ristiques.
            S√©lectionnez les caract√©ristiques ci-dessous pour pr√©dire la plage de prix d'un t√©l√©phone.
            """
        )
        
        # Charger les donn√©es
        train_df, test_df = load_data()

        # Pr√©traiter les donn√©es
        X, y, test_df_processed = preprocess_data(train_df, test_df)
        
        if X is None or y is None:
            st.stop()  # Arr√™ter l'ex√©cution si les donn√©es sont incorrectes

        # Interface utilisateur pour pr√©dire le prix d'un t√©l√©phone
        st.write("### Entrez les caract√©ristiques du t√©l√©phone pour pr√©dire sa plage de prix")

        # Champs de saisie pour les caract√©ristiques du t√©l√©phone
        battery_power = st.number_input("Battery Power", min_value=0, help="La puissance de la batterie du t√©l√©phone.")
        blue = st.selectbox("Bluetooth (blue)", [0, 1], help="Indique si le t√©l√©phone dispose de Bluetooth.")
        clock_speed = st.number_input("Clock Speed", min_value=0.0, format="%.2f", help="Vitesse d'horloge du t√©l√©phone.")
        dual_sim = st.selectbox("Dual SIM", [0, 1], help="Indique si le t√©l√©phone est dual SIM.")
        fc = st.number_input("Front Camera", min_value=0, help="Nombre de m√©gapixels de la cam√©ra frontale.")
        four_g = st.selectbox("4G", [0, 1], help="Indique si le t√©l√©phone prend en charge la 4G.")
        int_memory = st.number_input("Internal Memory", min_value=0, help="M√©moire interne du t√©l√©phone (en Go).")
        m_dep = st.number_input("Mobile Depth", min_value=0.0, format="%.2f", help="Profondeur du t√©l√©phone (en mm).")
        mobile_wt = st.number_input("Mobile Weight", min_value=0, help="Poids du t√©l√©phone (en grammes).")
        n_cores = st.number_input("Number of Cores", min_value=0, help="Nombre de c≈ìurs du processeur du t√©l√©phone.")
        pc = st.number_input("Primary Camera", min_value=0, help="Nombre de m√©gapixels de la cam√©ra principale.")
        px_height = st.number_input("Pixel Height", min_value=0, help="Hauteur de l'√©cran en pixels.")
        px_width = st.number_input("Pixel Width", min_value=0, help="Largeur de l'√©cran en pixels.")
        ram = st.number_input("RAM", min_value=0, help="M√©moire vive du t√©l√©phone (en Mo).")
        sc_h = st.number_input("Screen Height", min_value=0, help="Hauteur de l'√©cran du t√©l√©phone (en pouces).")
        sc_w = st.number_input("Screen Width", min_value=0, help="Largeur de l'√©cran du t√©l√©phone (en pouces).")
        talk_time = st.number_input("Talk Time", min_value=0, help="Autonomie en mode conversation (en heures).")
        three_g = st.selectbox("3G", [0, 1], help="Indique si le t√©l√©phone prend en charge la 3G.")
        touch_screen = st.selectbox("Touch Screen", [0, 1], help="Indique si le t√©l√©phone a un √©cran tactile.")
        wifi = st.selectbox("WiFi", [0, 1], help="Indique si le t√©l√©phone prend en charge le WiFi.")

        # Cr√©er un dictionnaire avec les valeurs saisies par l'utilisateur
        user_input = {
            "battery_power": battery_power,
            "blue": blue,
            "clock_speed": clock_speed,
            "dual_sim": dual_sim,
            "fc": fc,
            "four_g": four_g,
            "int_memory": int_memory,
            "m_dep": m_dep,
            "mobile_wt": mobile_wt,
            "n_cores": n_cores,
            "pc": pc,
            "px_height": px_height,
            "px_width": px_width,
            "ram": ram,
            "sc_h": sc_h,
            "sc_w": sc_w,
            "talk_time": talk_time,
            "three_g": three_g,
            "touch_screen": touch_screen,
            "wifi": wifi,
        }

        # Convertir le dictionnaire en DataFrame
        input_df = pd.DataFrame(user_input, index=[0])

        # V√©rifier si le mod√®le est charg√©
        if st.session_state.model:
            model = st.session_state.model
            prediction = predict_price(model, input_df)
            st.write(f"La plage de prix pr√©dite pour ce t√©l√©phone est : **{prediction}**")

        else:
            st.write("Mod√®le non disponible. Veuillez entra√Æner un mod√®le dans l'onglet '√âvaluation du mod√®le'.")

    if app_mode == "√âvaluation du mod√®le":
        st.title("√âvaluation du Mod√®le")
        st.markdown(
            """
            Cette section vous permet d'√©valuer la performance du mod√®le en termes de pr√©cision et d'autres m√©triques.
            """
        )

        # Charger les donn√©es
        train_df, test_df = load_data()

        # Pr√©traiter les donn√©es
        X, y, test_df_processed = preprocess_data(train_df, test_df)
        
        if X is None or y is None:
            st.stop()  # Arr√™ter l'ex√©cution si les donn√©es sont incorrectes

        # Entra√Æner les mod√®les
        st.write("### Entra√Ænement du mod√®le Random Forest")
        model_rf, accuracy_rf, classification_rep_rf, confusion_mat_rf = train_random_forest(X, y)
        st.write(f"Pr√©cision du mod√®le Random Forest : {accuracy_rf * 100:.2f}%")
        st.write("### Rapport de Classification - Random Forest")
        st.write(classification_rep_rf)
        st.write("### Matrice de Confusion - Random Forest")
        fig_rf, ax_rf = plt.subplots(figsize=(8, 6))
        sns.heatmap(confusion_mat_rf, annot=True, fmt="d", cmap="Blues", xticklabels=["Classe 0", "Classe 1", "Classe 2", "Classe 3"], yticklabels=["Classe 0", "Classe 1", "Classe 2", "Classe 3"])
        st.pyplot(fig_rf)

        # Visualisation de l'importance des caract√©ristiques pour Random Forest
        st.write("### Importance des Caract√©ristiques - Random Forest")
        plot_feature_importance(model_rf)

        st.write("### Entra√Ænement du mod√®le de R√©gression Logistique")
        model_lr, accuracy_lr, classification_rep_lr, confusion_mat_lr = train_logistic_regression(X, y)
        st.write(f"Pr√©cision du mod√®le de R√©gression Logistique : {accuracy_lr * 100:.2f}%")
        st.write("### Rapport de Classification - R√©gression Logistique")
        st.write(classification_rep_lr)
        st.write("### Matrice de Confusion - R√©gression Logistique")
        fig_lr, ax_lr = plt.subplots(figsize=(8, 6))
        sns.heatmap(confusion_mat_lr, annot=True, fmt="d", cmap="Blues", xticklabels=["Classe 0", "Classe 1", "Classe 2", "Classe 3"], yticklabels=["Classe 0", "Classe 1", "Classe 2", "Classe 3"])
        st.pyplot(fig_lr)

        # Enregistrer les mod√®les dans session_state pour pr√©dictions ult√©rieures
        st.session_state.model_rf = model_rf
        st.session_state.model_lr = model_lr

if __name__ == "__main__":
    main()
